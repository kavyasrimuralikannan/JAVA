import java.util.*;

class Solution {

    // Polynomial class
    class Poly {
        Map<String, Integer> map = new HashMap<>();

        Poly() {}

        Poly(int val) {
            if (val != 0) map.put("", val);
        }

        Poly(String var) {
            map.put(var, 1);
        }

        Poly add(Poly other) {
            Poly res = new Poly();
            res.map.putAll(this.map);
            for (String k : other.map.keySet()) {
                res.map.put(k, res.map.getOrDefault(k, 0) + other.map.get(k));
            }
            return res;
        }

        Poly sub(Poly other) {
            Poly res = new Poly();
            res.map.putAll(this.map);
            for (String k : other.map.keySet()) {
                res.map.put(k, res.map.getOrDefault(k, 0) - other.map.get(k));
            }
            return res;
        }

        Poly mul(Poly other) {
            Poly res = new Poly();
            for (String k1 : this.map.keySet()) {
                for (String k2 : other.map.keySet()) {
                    String key = merge(k1, k2);
                    res.map.put(key,
                        res.map.getOrDefault(key, 0) + this.map.get(k1) * other.map.get(k2));
                }
            }
            return res;
        }

        String merge(String a, String b) {
            if (a.isEmpty()) return b;
            if (b.isEmpty()) return a;
            List<String> vars = new ArrayList<>();
            vars.addAll(Arrays.asList(a.split("\\*")));
            vars.addAll(Arrays.asList(b.split("\\*")));
            Collections.sort(vars);
            return String.join("*", vars);
        }
    }

    public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {
        Map<String, Integer> eval = new HashMap<>();
        for (int i = 0; i < evalvars.length; i++) {
            eval.put(evalvars[i], evalints[i]);
        }

        Poly poly = parse(expression, eval);

        List<String> result = new ArrayList<>();
        List<String> keys = new ArrayList<>(poly.map.keySet());

        keys.sort((a, b) -> {
            int da = a.isEmpty() ? 0 : a.split("\\*").length;
            int db = b.isEmpty() ? 0 : b.split("\\*").length;
            if (da != db) return db - da;
            return a.compareTo(b);
        });

        for (String k : keys) {
            int coef = poly.map.get(k);
            if (coef == 0) continue;
            if (k.isEmpty()) {
                result.add(String.valueOf(coef));
            } else {
                result.add(coef + "*" + k);
            }
        }
        return result;
    }

    private Poly parse(String expr, Map<String, Integer> eval) {
        Stack<Poly> vals = new Stack<>();
        Stack<Character> ops = new Stack<>();

        for (int i = 0; i < expr.length(); ) {
            char c = expr.charAt(i);
            if (c == ' ') {
                i++;
            } else if (c == '(') {
                ops.push(c);
                i++;
            } else if (c == ')') {
                while (ops.peek() != '(') evalOp(vals, ops.pop());
                ops.pop();
                i++;
            } else if (c == '+' || c == '-' || c == '*') {
                while (!ops.isEmpty() && precedence(ops.peek()) >= precedence(c)) {
                    evalOp(vals, ops.pop());
                }
                ops.push(c);
                i++;
            } else {
                int j = i;
                while (j < expr.length() && expr.charAt(j) != ' ' &&
                       expr.charAt(j) != '+' && expr.charAt(j) != '-' &&
                       expr.charAt(j) != '*' && expr.charAt(j) != '(' &&
                       expr.charAt(j) != ')') j++;

                String token = expr.substring(i, j);
                Poly p;
                if (Character.isDigit(token.charAt(0))) {
                    p = new Poly(Integer.parseInt(token));
                } else if (eval.containsKey(token)) {
                    p = new Poly(eval.get(token));
                } else {
                    p = new Poly(token);
                }
                vals.push(p);
                i = j;
            }
        }

        while (!ops.isEmpty()) evalOp(vals, ops.pop());
        return vals.pop();
    }

    private void evalOp(Stack<Poly> vals, char op) {
        Poly b = vals.pop();
        Poly a = vals.pop();
        if (op == '+') vals.push(a.add(b));
        else if (op == '-') vals.push(a.sub(b));
        else vals.push(a.mul(b));
    }

    private int precedence(char op) {
        if (op == '*' ) return 2;
        if (op == '+' || op == '-') return 1;
        return 0;
    }
}
